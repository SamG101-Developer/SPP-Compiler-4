NOW

Superimposition:
-- Sup scopes for certain generics only (sup std::Vec[std::Bool] {} ).
-- Disallow sup-scopes with overlapping attributes.

Generics:
-- Function specialization.
-- Using different generic identifiers for sup->cls doesn't work (currently have to be the same).

Pins:
-- Can unpin a value being borrowed, but the coroutine or future must be invalidated.
-- A coroutine or future is pinned if any of its arguments are pinned (ie are borrowed from a pinned value).
-- What about "ret coroutine(&argument)" => the argument is pinned, but the coroutine doesn't exist as a symbol.

Object initialization:
-- Sup initialization
    -- Replace sup-scopes with the generically-filled scopes?
    -- What about inheriting the same superclass with different generics?)

Functions:
-- Generic fall-through for sup-inheritance blocks => see sup-initialization.
-- Partial functions? Use "_" to convert functions to lambdas with some values set.
-- Tuple function folding ie "function(a).." needs to call "function" continuously with each element of "a". Do I want this?
-- Overriding a function doesn't remove the base overload from consideration.

Global constants:
-- Prevent unpinning global constants.
-- How to do arrays with no array literal => might need to add one?
-- Using global constants from other modules doesn't work.

Types:
-- Special `Copy` type that doesn't "move" the value.
-- Prevent type redeclaration in the same scope (except `Self`)` - check generics on this too (sup <-> cls)?.
-- Numerical type indexing
-- Add `Self` back into parsing once typedefs are done, and inject typedef's analysis (=> symbol) into correct scope.

Other:
-- Errors across files (ie conflicting overloads in global scopes of different files), use tokens of the same file - confusing error message.
-- Double analyse `loop` body, avoiding messing up `exit` loop counting.


FUTURE

Typedefs:
-- Remove for now & redo the lot
-- Importing typedefs (see TypedefStatementAst::generate() comments).
-- Sup-typedefs (and check they exist on the superclass; modify existing method checks).
-- Nested typedefs: use std::(ops::Add, ops::Sub) works, but not std::{ops::{Add, Sub}, Vec}
-- Change typedefs to work like "destructures" (recursive) in the parser & analysis.

Types:
-- Generic constraints
-- Intersection types

Patterns:
-- Boolean field access ie `case object then .empty() { ... } .is_value() { ... } etc`
