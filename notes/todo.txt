NOW

Pins:
-- Can unpin a value being borrowed, but the coroutine or future must be invalidated.
-- A coroutine or future is pinned if any of its arguments are pinned (ie are borrowed from a pinned value).
-- What about "ret coroutine(&argument)" => the argument is pinned, but the coroutine doesn't exist as a symbol.

Functions:
-- Conflicting overloads don't work for generic classes?
-- Tuple function folding ie "function(a).." needs to call "function" continuously with each element of "a". Do I want this?
-- Overriding a function doesn't remove the base overload from consideration.
    -- Move the function prototypes conflict checker to a function
    -- Use the conflict checker to eliminate base methods (only way to have a conflict is if the base method is still in consideration).

Types:
-- Add an array literal syntax, and consider empty arrays.
-- Special `Copy` type that doesn't "move" the value.
-- Prevent type redeclaration in the same scope (except `Self`)` - check generics on this too (sup <-> cls)?.
-- Numerical type indexing
-- Add `Self` back into parsing once typedefs are done, and inject typedef's analysis (=> symbol) into correct scope.
-- Too many generics or invalid name generics throw a Python error.

Case blocks
-- Separate rule for `else case` for an `elif` like block (unrelated condition, related block).
-- Union type destructure shouldn't allow for multiple types to be destructured if an attribute is used.

Other:
-- Errors across files (ie conflicting overloads in global scopes of different files), use tokens of the same file - confusing error message.
-- Double analyse `loop` body, avoiding messing up `exit` loop counting.
-- Expand `gen with` to `loop` and `gen`.
-- Tuples as case conditions -> resetting symbols.
-- Null coalescing operator `??` support.
-- Generics that are inferred from variadic parameter become tuples not the element.

Superimposition:
-- Sup scopes for certain generics only (sup std::Vec[std::Bool] {} ).

Re-add:
-- Conflicting function definitions.
-- Check members exist on superclasses.


FUTURE

Typedefs:
-- Add support for generic typedefs (type MyVector[T] = std::Vec[T])

Types:
-- Generic constraints
-- Intersection types => make a temporary type and superimpose all composite types onto it.

Patterns:
-- Boolean field access ie `case object then .empty() { ... } .is_value() { ... } etc`

Lambdas:
-- Everything to do with lambdas
-- Pinning captured values?
-- Map partial functions into lambdas with fixed captures.

UNDECIDED

Generics:
-- The "sup" generic identifiers should be able to be different from "cls" generic identifiers, otherwise error? Superclasses?
-- Otherwise could use typedefs to map the generic identifiers to different names.
