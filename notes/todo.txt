Generics:
-- Ban generic arguments from being `Void` for attributes (analyse class after generic substitution).
-- All things generic constraints.
-- Ban member access on generic types (for now, until constraints are implemented => constraints as sup-scopes).
-- Replace sup-scopes on genericized classes with generic conversion fallthrough (into sup-methods etc)

Binary expressions:
-- Rearrange from parsed AST order to correct AST order (current implementation is bugged).

Coroutines:
-- Check memory status of yielded objects.
-- Check the type of yielded, returned, and sent objects against the `Gen[Yield, Return, Send]` type parameters.
-- Add `cor` for couroutines?
    -- Parsing rule allows for conventions for yielding & sending
    -- CoroutinePrototypeAST can inherit from FunctionPrototypeAST
    -- Some checks the same, others specific to each (yielding, returning)
    -- Only allow yielding from coroutines

Namespaced types:
-- Allowing `use` to link new type names to namespaced types' class prototypes.

Unions:
-- Union types & their semantics (assignment especially)
-- Reintroduce `is` .. expression for unions.

Sup classes
-- Ensure overriden methods exist on the `sup` class.
-- Allow specialization of sup-class methods in the `sup` block.

Object initialization
-- Default class attribute values?
-- Sup initialization
-- What happens with giving > 1 value per attribute?

Placeholders
-- Placeholders in `let` and `patterns` (use the `_` character)
-- Use to shorthand partial functions? => convert into lambdas?

Error feedback
-- "Attribute ..." with wrong type: include the class name in the error message, ie "Class.attribute declared here" etc.
-- For types, "did you mean ..." doesn't work for namespaced types. Probably fixable with scope analysis.

Other
-- Binary member access for conditional branches
-- Tuple operations (unpacking, folding etc)
-- Mutability of borrows vs value: required (mut x: &mut T) in order to mutate attribute atm.
-- The `Self` type needs to change for parameter types.
-- Variables not always introduced into pattern scope from patterns.
-- Comments take up lines in a file, but not after parsing (are removed in tokenizer -> keep the "\n")
-- Change parameters to be like local variables, allowing different types like `fun function(Point(x, y): Point) -> Point { ... }`
