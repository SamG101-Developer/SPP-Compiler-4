NOW

Functions:
-- Tuple function folding ie "function(a).." needs to call "function" continuously with each element of "a".
-- Overriding a function doesn't remove the base overload from consideration.

Types:
-- Numerical type indexing.
-- Add `Self` back into parsing once typedefs are done, and inject typedef's analysis (=> symbol) into correct scope.
-- Too many generics or invalid name generics throw a Python error.
-- Typedefs don't work as generic arguments (comparison-wise), probably need converting to "old_symbol" first.
-- Using generics for an identifier (in sup) different to the cls-level generics doesn't work (could be a feature?).

Case blocks:
-- Look at anonymous branching? Allowing for a non-pattern pattern block.
-- Alias attributes: would need some sort of syntax like `is Some(val => alias)`?
-- Flow typing: should be able to use the symbol if no destructuring took place.

Other:
-- Errors across files (ie conflicting overloads in global scopes of different files), use tokens of the same file - confusing error message.
-- Expand `gen with` to `loop` and `gen`.
-- Null coalescing operator `??` support.
-- Look at variadic-type variadic parameters (probably won't work).
-- Maybe re-write the symbol/scoping system: get_all => get_all_vars, get_all_types etc.
-- Errors are the wrong way around for generic inference and attributes during object initialization. An incorrectly
named attribute will cause the generic inference to fail, rather than report the attribute error.

Inheritance:
-- Annotations for @public, @private, @protected, @friend
-- Abstract methods must be implemented on subclasses.
-- Default visibility is private.
-- Sup scopes for certain generics only: "sup std::Vec[std::Bool] {}".

FUTURE

Types:
-- Generic constraints
-- Intersection types => make a temporary type and superimpose all composite types onto it.

Patterns:
-- Boolean field access ie `case object then .empty() { ... } .is_value() { ... } etc`

Lambdas:
-- Everything to do with lambdas
-- Pinning captured values?
-- Map partial functions into lambdas with fixed captures.

Annotations:
-- Compiler output (@deprecated etc) and llvm annotations (@inline, @cold, @hot etc).
