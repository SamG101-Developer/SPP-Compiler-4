NOW

Functions:
-- Tuple function folding ie "function(a).." needs to call "function" continuously with each element of "a".
** Overriding a function doesn't remove the base overload from consideration.

Types:
-- Add an array literal syntax, and consider empty arrays.
-- Special `Copy` type that doesn't "move" the value.
-- Prevent type redeclaration in the same scope (except `Self`)` - check generics on this too (sup <-> cls)?
-- Numerical type indexing.
-- Add `Self` back into parsing once typedefs are done, and inject typedef's analysis (=> symbol) into correct scope.
-- Too many generics or invalid name generics throw a Python error.
-- Typedefs don't work as generic arguments (comparison-wise).

Case blocks:
-- Union type destructure shouldn't allow for multiple types to be destructured if an attribute is used.
-- Look at anonymous branching? Allowing for a non-pattern pattern block.
-- Tuples as case conditions -> resetting symbols.

Other:
-- Errors across files (ie conflicting overloads in global scopes of different files), use tokens of the same file - confusing error message.
-- Expand `gen with` to `loop` and `gen`.
-- Null coalescing operator `??` support.
-- Generics that are inferred from variadic parameter become tuples, not the element.

Superimposition:
-- Sup scopes for certain generics only (sup std::Vec[std::Bool] {} ).

Re-add:
-- Check members exist on superclasses.


FUTURE

Types:
-- Generic constraints
-- Intersection types => make a temporary type and superimpose all composite types onto it.

Patterns:
-- Boolean field access ie `case object then .empty() { ... } .is_value() { ... } etc`

Lambdas:
-- Everything to do with lambdas
-- Pinning captured values?
-- Map partial functions into lambdas with fixed captures.
