Generics:
-- Ban generic arguments from being `Void` for attributes (analyse class after substitution).
-- All things generic constraints (for `sup` just remove sup-scopes?).
-- Ban member access on generic types (for now, until constraints are implemented => constraints as sup-scopes).
-- Replace sup-scopes on genericized classes with generic conversion fallthrough (into sup-methods etc)

Binary expressions:
-- Rearrange from parsed AST order to correct AST order [IMPL + BUGGED].

Coroutines:
-- Check memory status of yielded objects.
-- Check the type of yielded, returned, and sent objects against the `Gen[Yield, Return, Send]` type parameters.

Namespaced types:
-- Allowing `use` to link new type names to namespaced types' class prototypes.

Keyword `is`:
-- Check that the LHS is a variant type: `Var[...]`
-- Check that the RHS is a type in the LHS's generic arguments.

Memory checks
-- The `borrow_ref` and `borrow_mut` need to be checked if moving an argument into a function.

Sup classes
-- Ensure overriden methods exist on the `sup` class.
-- Allow specialization of sup-class methods in the `sup` block.
-- In the end, only one `Fun...` with multiple specializations per overload should be generated for each unique method name.

Object initialization
-- Default struct values
-- Sup initialization
-- What happens with giving > 1 value per attribute?

Placeholders
-- Placeholders in `let` and `patterns`
-- Use to shorthand partial functions?

Other
-- Numeric postfix classes aren't defined but dont throw errors
-- Nested `let` statements ie `let Vector(direction, Pos(x, y, z)) = ...` doesn't work right now (copy from `case` which does work).
-- "Attribute ..." with wrong type: include the class name in the error message, ie "Class.attribute declared here" etc.
-- Tuple operations
-- Binary member access for conditional branches
-- Union types & their semantics (assignment especially)
-- For types, "did you mean ..." doesn't work for namespaced types. Probably fixable.
