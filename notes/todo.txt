Generics:
-- All things generic constraints (functions, classes, sup-blocks, member access).
-- Sup scopes for certain generics only.
-- Function specialization.
-- Using different generic identifiers for sup->cls doesn't work (currently have to be the same).

Pins:
-- Cannot unpin a value being borrowed by an async function unless await has been called on the corresponding future.
-- Can unpin a value being borrowed by a coroutine, but the coroutine will be invalidated.
-- A coroutine or future is pinned if any of its arguments are pinned (ie are borrowed from a pinned value).
-- Same rules for branches of "if" blocks. All mus result in the same pinning state.

Object initialization:
-- Sup initialization
    -- Replace sup-scopes with the generically-filled scopes?
    -- What about inheriting the same superclass with different generics?)

Patterns:
-- Boolean field access ie `case object then .empty() { ... } .is_value() { ... } etc`

Tuples:
-- Tuple function folding: fold-able tuples need to be marked as so, then the function fold only folds those tuples.

Functions:
-- Re-add the "cannot use self in module function" check (removed for false positives)
-- Generic fall-through for sup-inheritance blocks => see sup-initialization.
-- Partial functions? Use "_" to convert functions to lambdas with some values set.
-- Functions with destructured parameters and no members act as if they have members (destructure is injected).
-- Static methods injecting a "self" argument even though it shouldn't be there.

Typedefs:
-- Redo the lot
-- Importing typedefs (see TypedefStatementAst::generate() comments).
-- Sup-typedefs.
-- Nested typedefs: use std::(ops::Add, ops::Sub) works, but not std::{ops::{Add, Sub}, Vec} -- make more cyclic like "let" statements.

Global constants:
-- Global constants move semantics (not movable). Add a GlobalConstantAst?
-- The GlobalConstantAst will be used for function -> class conversions, removing the need for `_sup_let_type`

Types:
-- Special `Copy` type that doesn't "move" the value.
-- Prevent type redeclaration in the same scope (except `Self`)`.
-- Union types throw generic-oriented errors

Expressions:
-- Operations ie `1 + 2`, `2` should be taken by-ref, but there is no way to do this currently.

Self-type:
-- Disallow "Self" being used as a generic argument in "sup" blocks as arguments (recursive types)
-- Disallow "Self" being used as a generic parameter's default value in `cls` blocks (recursive types).

Other:
-- Variable declared as uninitialized, initialized only on some branches -> "potentially uninitialized variable" error.
-- Errors across files (ie conflicting overloads in global scopes of different files), use tokens of the same file - confusing error message.
