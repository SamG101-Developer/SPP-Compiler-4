NOW

Functions:
-- Tuple function folding ie "function(a).." needs to call "function" continuously with each element of "a".
-- Overriding a function doesn't remove the base overload from consideration.

Types:
-- Prevent type redeclaration in the same scope (except `Self`)` - check generics on this too (sup <-> cls)?
-- Numerical type indexing.
-- Add `Self` back into parsing once typedefs are done, and inject typedef's analysis (=> symbol) into correct scope.
-- Too many generics or invalid name generics throw a Python error.
-- Typedefs don't work as generic arguments (comparison-wise), probably need converting to "old_symbol" first.

Case blocks:
-- Look at anonymous branching? Allowing for a non-pattern pattern block.
-- Alias attributes: would need some sort of syntax like `is Some(val => alias)`?
-- Flow typing: should be able to use the symbol if no destructuring took place.

Other:
-- Errors across files (ie conflicting overloads in global scopes of different files), use tokens of the same file - confusing error message.
-- Expand `gen with` to `loop` and `gen`.
-- Null coalescing operator `??` support.
-- Generics that are inferred from variadic parameter become tuples, not the element.
-- The `with` block (checking `CtxMut` or `CtxRef` is superimposed).

Superimposition:
-- Sup scopes for certain generics only: "sup std::Vec[std::Bool] {}".

Re-add:
-- Check members exist on superclasses.


FUTURE

Types:
-- Generic constraints
-- Intersection types => make a temporary type and superimpose all composite types onto it.

Patterns:
-- Boolean field access ie `case object then .empty() { ... } .is_value() { ... } etc`

Lambdas:
-- Everything to do with lambdas
-- Pinning captured values?
-- Map partial functions into lambdas with fixed captures.
