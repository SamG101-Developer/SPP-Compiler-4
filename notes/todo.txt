Generics:
-- All things generic constraints (functions, classes, sup-blocks, member access).
-- Replace sup-scopes on genericized classes with generic conversion fallthrough (into sup-methods etc)

Binary expressions:
-- Rearrange from parsed AST order to correct AST order (current implementation is bugged).

Coroutines:
-- Check memory status of yielded objects.
-- Check the type of sent objects against the `Send` generic parameter.
-- Fix the return type to check against the `Return` generic parameter (not the function return type) for coroutines.

Namespaced types:
-- Allowing `use` to link new type names to namespaced types' class prototypes.

Sup classes
-- Ensure overridden methods exist on the `sup` class.
-- Allow specialization of sup-class methods in the `sup` block.

Object initialization
-- Default class attribute values?
-- Sup initialization
-- What happens with giving > 1 value per attribute?

Placeholders
-- Placeholders in `let` and `patterns` (use the `_` character)
-- Use to shorthand partial functions? => convert into lambdas?

Patterns:
-- Don't mark destructure variables as "moved" until entire "case" expression is done (could be destructured on multiple branches)
-- Convert operator to function + analyse function call (ie `1.eq(2)` from `1 then == 2`)
-- Semantics for `is ...`.
-- Binary field access ie `case object then .empty() { ... } .is_value() { ... } etc`

Other
-- Tuple operations (unpacking, folding etc)
-- The `Self` type needs to change for parameter types.
-- Change parameters to be like local variables, allowing different types like `fun function(Point(x, y): Point) -> Point { ... }`
-- Allow global constants (can't be (partially-)moved, can be copied or "&" though)
-- Static methods not callable from class type (parsing issue)
-- Tuple destructuring with ".." in the middle assigns wrong types to variables on the right of ".."
-- Some namespaced types don't analyse as namespaced
-- Suggest similar namespaces for undefined namespaces
-- Special `Copy` type that doesn't "move" the value
